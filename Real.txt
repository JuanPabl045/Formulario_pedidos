import com.fazecast.jSerialComm.SerialPort;
import org.opencv.core.*;
import org.opencv.imgproc.Imgproc;
import org.opencv.videoio.VideoCapture;

import javax.swing.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.util.ArrayList;
import java.util.List;
import java.awt.GridLayout;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

public class Intro {
    private static volatile boolean running = true;
    
    // Campos para la comunicación serial y la acción estable
    private static SerialPort serialPort; 
    private static String stableAction = "N/A"; 

    public static void main(String[] args) {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        
        // --- Configuración del puerto serial ---
        String portName = "COM3"; // ¡Asegúrate de que este sea el puerto correcto!
        serialPort = SerialPort.getCommPort(portName);
        serialPort.setComPortParameters(9600, 8, 1, SerialPort.NO_PARITY);
        serialPort.setComPortTimeouts(SerialPort.TIMEOUT_WRITE_BLOCKING, 0, 0);

        if (!serialPort.openPort()) {
            System.err.println("❌ Advertencia: No se pudo abrir el puerto serial en " + portName);
        } else {
            System.out.println("✅ Puerto serial abierto en " + portName);
        }
        // ----------------------------------------

        VideoCapture camera = new VideoCapture(1);
        if (!camera.isOpened()) {
            System.out.println("❌ No se detecta la cámara");
            if (serialPort != null && serialPort.isOpen()) serialPort.closePort();
            return;
        }

        Mat frame = new Mat();

        // Crear GUI en EDT
        JFrame ventana = new JFrame("Detección de Gestos");
        JLabel lbl = new JLabel();
        ventana.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        ventana.add(lbl);
        ventana.setSize(640, 480);
        ventana.setVisible(true);

        ventana.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosed(WindowEvent e) {
                running = false;
            }
        });

        // --- Controles de calibración HSV (sliders) ---
        JSlider hMinSlider = new JSlider(0, 180, 0);
        JSlider hMaxSlider = new JSlider(0, 180, 20);
        JSlider sMinSlider = new JSlider(0, 255, 30);
        JSlider sMaxSlider = new JSlider(0, 255, 150);
        JSlider vMinSlider = new JSlider(0, 255, 60);
        JSlider vMaxSlider = new JSlider(0, 255, 255);

        JFrame controlFrame = new JFrame("Calibrador HSV");
        controlFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        controlFrame.setLayout(new GridLayout(6, 2));
        controlFrame.add(new JLabel("H min")); controlFrame.add(hMinSlider);
        controlFrame.add(new JLabel("H max")); controlFrame.add(hMaxSlider);
        controlFrame.add(new JLabel("S min")); controlFrame.add(sMinSlider);
        controlFrame.add(new JLabel("S max")); controlFrame.add(sMaxSlider);
        controlFrame.add(new JLabel("V min")); controlFrame.add(vMinSlider);
        controlFrame.add(new JLabel("V max")); controlFrame.add(vMaxSlider);
        controlFrame.pack();
        controlFrame.setLocation(660, 50);
        controlFrame.setVisible(true);

        // Ventana para mostrar la máscara (debug)
        JFrame maskFrame = new JFrame("Mask");
        JLabel maskLabel = new JLabel();
        maskFrame.add(maskLabel);
        maskFrame.setSize(320, 240);
        maskFrame.setLocation(660, 350);
        maskFrame.setVisible(true);

        controlFrame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosed(WindowEvent e) {
                // no cerramos la app por cerrar el calibrador
            }
        });

        maskFrame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosed(WindowEvent e) {
                // no cerramos la app por cerrar la máscara
            }
        });

        // Kernel y Mats reutilizables
        Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_ELLIPSE, new Size(5, 5));
        Mat blurred = new Mat();
        Mat hsv = new Mat();
        Mat mask = new Mat();
        Mat hierarchy = new Mat();

        // --- Temporal smoothing / debounce ---
        final int WINDOW = 8;           // longitud de la ventana (frames)
        final int CONFIRM = 6;          // mínimo de apariciones en la ventana para confirmar
        LinkedList<String> recentActions = new LinkedList<>();
        String lastPrintedAction = "";  
        // -------------------------------------

        while (running) {
            if (!camera.read(frame) || frame.empty()) {
                if (!ventana.isDisplayable()) break;
                continue;
            }

            // Preprocesado
            Imgproc.GaussianBlur(frame, blurred, new Size(5, 5), 0);
            Imgproc.cvtColor(blurred, hsv, Imgproc.COLOR_BGR2HSV);

            // Leer sliders y actualizar rango HSV
            Scalar lower = new Scalar(hMinSlider.getValue(), sMinSlider.getValue(), vMinSlider.getValue());
            Scalar upper = new Scalar(hMaxSlider.getValue(), sMaxSlider.getValue(), vMaxSlider.getValue());

            Core.inRange(hsv, lower, upper, mask);

            // Mostrar máscara en ventana de debug
            BufferedImage maskImg = matToBufferedImage(mask);
            SwingUtilities.invokeLater(() -> {
                maskLabel.setIcon(new ImageIcon(maskImg));
                maskLabel.repaint();
            });

            // Morfología para limpiar ruido
            Imgproc.morphologyEx(mask, mask, Imgproc.MORPH_OPEN, kernel);
            Imgproc.morphologyEx(mask, mask, Imgproc.MORPH_CLOSE, kernel);

            // Encontrar contornos
            List<MatOfPoint> contornos = new ArrayList<>();
            Imgproc.findContours(mask, contornos, hierarchy, Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);

            String action = "N/A"; // acción detectada en este frame

            if (!contornos.isEmpty()) {
                // Elegir contorno más grande
                double maxArea = 0;
                MatOfPoint maxContour = null;
                for (MatOfPoint c : contornos) {
                    double area = Imgproc.contourArea(c);
                    if (area > maxArea) {
                        maxArea = area;
                        maxContour = c;
                    }
                }

                if (maxContour != null && maxArea > 1000) { // umbral de área mínimo
                    // Dibujar contorno
                    Imgproc.drawContours(frame, List.of(maxContour), -1, new Scalar(0, 255, 0), 2);

                    // Convex hull (devuelve índices)
                    MatOfInt hull = new MatOfInt();
                    Imgproc.convexHull(maxContour, hull);

                    Point[] contourArray = maxContour.toArray();
                    int[] hullIndices = hull.toArray();

                    if (hullIndices.length > 2 && contourArray.length >= 3) {
                        
                        // --> Bloque TRY-CATCH para evitar CvException <---
                        try {
                            // Dibujar hull como polígono
                            MatOfPoint hullPoints = new MatOfPoint();
                            Point[] hullPts = new Point[hullIndices.length];
                            for (int i = 0; i < hullIndices.length; i++) {
                                hullPts[i] = contourArray[hullIndices[i]];
                            }
                            hullPoints.fromArray(hullPts);
                            Imgproc.drawContours(frame, List.of(hullPoints), -1, new Scalar(255, 0, 0), 2);

                            // Defectos convexos
                            MatOfInt4 defects = new MatOfInt4();
                            Imgproc.convexityDefects(maxContour, hull, defects); // Posible punto de fallo

                            int fingerCount = 0;
                            if (defects.rows() > 0) {
                                for (int i = 0; i < defects.rows(); i++) {
                                    double[] d = defects.get(i, 0);
                                    int startIdx = (int) d[0];
                                    int endIdx = (int) d[1];
                                    int farIdx = (int) d[2];
                                    double depthRaw = d[3];
                                    double depth = depthRaw / 256.0;

                                    if (startIdx < 0 || endIdx < 0 || farIdx < 0 ||
                                            startIdx >= contourArray.length || endIdx >= contourArray.length || farIdx >= contourArray.length) {
                                        continue;
                                    }

                                    Point start = contourArray[startIdx];
                                    Point end = contourArray[endIdx];
                                    Point far = contourArray[farIdx];

                                    // Filtrar por profundidad y ángulo
                                    double angle = angleBetween(start, far, end);
                                    if (depth > 10 && angle < 90) {
                                        fingerCount++;
                                        Imgproc.circle(frame, far, 6, new Scalar(0, 0, 255), -1);
                                    }
                                }
                            }

                            // Acción por fingerCount
                            if (fingerCount >= 4) {
                                action = "LUZ ON";
                            } else if (fingerCount == 0) {
                                action = "LUZ OFF";
                            } else if (fingerCount == 1) {
                                action = "VENTILADOR ON";
                            } else if (fingerCount == 2) {
                                action = "VENTILADOR OFF";
                            } else {
                                action = "N/A";
                            }

                            // liberar mats locales (si el try fue exitoso)
                            defects.release();
                            hullPoints.release();
                            
                        } catch (CvException e) {
                            System.err.println("Advertencia: Salto de frame por contorno ruidoso (CvException).");
                            // Si falla, 'action' se mantiene como "N/A" para este frame
                        }
                        // Liberar hull (creado fuera del try, siempre debe ser liberado)
                        hull.release(); 
                    } else {
                        // Si no hay suficientes puntos para el hull, liberamos
                        hull.release();
                    }
                }
            }

            // --- Smoothing / Debounce ---
            recentActions.add(action);
            if (recentActions.size() > WINDOW) recentActions.removeFirst();

            Map<String, Integer> freq = new HashMap<>();
            for (String a : recentActions) freq.put(a, freq.getOrDefault(a, 0) + 1);

            String mode = null;
            int modeCount = 0;
            for (Map.Entry<String, Integer> e : freq.entrySet()) {
                if (e.getValue() > modeCount) {
                    modeCount = e.getValue();
                    mode = e.getKey();
                }
            }

            if (mode != null && modeCount >= CONFIRM) {
                // Si la acción estable cambia, enviamos el comando serial
                if (!mode.equals(stableAction)) {
                    stableAction = mode;
                    enviarComando(stableAction); // <-- Envía el comando estable
                }
            }
            // -----------------------------

            // Mostrar la acción estable en el frame
            Imgproc.putText(frame, stableAction, new Point(10, 30),
                    Imgproc.FONT_HERSHEY_SIMPLEX, 1.0, new Scalar(255, 0, 0), 2);

            // solo imprimir en consola cuando la acción estable cambie
            if (!stableAction.equals(lastPrintedAction)) {
                System.out.println("Acción estable: " + stableAction);
                lastPrintedAction = stableAction;
            }

            // Mostrar frame en Swing (actualizar en EDT)
            BufferedImage image = matToBufferedImage(frame);
            SwingUtilities.invokeLater(() -> {
                lbl.setIcon(new ImageIcon(image));
                lbl.repaint();
            });

            // Limitar FPS (~30)
            try {
                Thread.sleep(33);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        // --- Limpiar al salir ---
        camera.release();
        if (serialPort != null && serialPort.isOpen()) serialPort.closePort(); 
        frame.release();
        blurred.release();
        hsv.release();
        mask.release();
        hierarchy.release();
        kernel.release();
        ventana.dispose();
        controlFrame.dispose();
        maskFrame.dispose();
        System.out.println("Aplicación finalizada. Puerto serial cerrado.");
    }

    private static void enviarComando(String comando) {
        if (serialPort == null || !serialPort.isOpen()) {
             return; 
        }
        try {
            // El '\n' (nueva línea) es crucial para que el ESP32 sepa cuándo termina el comando
            String command = comando + "\n"; 
            int bytesWritten = serialPort.writeBytes(command.getBytes(), command.length());
            
            if (bytesWritten != command.length()) {
                System.err.println("Error al enviar el comando: " + comando);
            } else {
                // No imprimimos nada aquí para evitar saturar la consola, ya se imprime la acción estable
            }
        } catch (Exception e) {
            System.err.println("Error al escribir en el puerto serial: " + e.getMessage());
        }
    }
    
    // Calcula el ángulo en el punto 'b' entre los vectores ba y bc (tu implementación original)
    private static double angleBetween(Point a, Point b, Point c) {
        double[] v1 = {a.x - b.x, a.y - b.y};
        double[] v2 = {c.x - b.x, c.y - b.y};
        double dot = v1[0] * v2[0] + v1[1] * v2[1];
        double mag1 = Math.hypot(v1[0], v1[1]);
        double mag2 = Math.hypot(v2[0], v2[1]);
        if (mag1 * mag2 == 0) return 180.0;
        double cos = dot / (mag1 * mag2);
        cos = Math.max(-1.0, Math.min(1.0, cos));
        return Math.toDegrees(Math.acos(cos));
    }

    // Método de utilidad para convertir un objeto Mat de OpenCV a un BufferedImage de Java (tu implementación original)
    public static BufferedImage matToBufferedImage(Mat mat) {
        int type = mat.channels() == 1 ? BufferedImage.TYPE_BYTE_GRAY : BufferedImage.TYPE_3BYTE_BGR;
        int bufferSize = mat.channels() * mat.cols() * mat.rows();
        byte[] b = new byte[bufferSize];
        mat.get(0, 0, b);
        BufferedImage image = new BufferedImage(mat.cols(), mat.rows(), type);
        final byte[] targetPixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();
        System.arraycopy(b, 0, targetPixels, 0, b.length);
        return image;
    }
}